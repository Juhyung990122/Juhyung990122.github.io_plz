{"componentChunkName":"component---src-templates-blog-post-js","path":"/Frontend_log/2020-09-10-TIL2/","result":{"data":{"site":{"siteMetadata":{"title":"여름산책","author":"이주형","siteUrl":"https://juhyung990122.github.io","comment":{"disqusShortName":"Guinness990122","utterances":"Juhyung990122/Juhyung990122"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"6cebf50c-c626-59cc-bf90-34d3329b41b4","excerpt":"🌟우아한 테크러닝 4회차 🎯promise 비동기 \nconst x = 10;\nconst y = x * 10;\n동시실행 가능? -> 못함 왜? -> x가 할당되기 전이기 때문(dependency) == 변수적 의존성 const x = () => 10;\nconst y = x() * 10;\nx값 확정순간은 y가 호출할때이므로 실행 가능 -> 지연호출 Promise는 지연과 비슷\n두개의 함수를 전달하기위해 함수호출\nconst p = new Promise(funcion(resolve,reject…","html":"<h2 id=\"우아한-테크러닝-4회차\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC%EB%9F%AC%EB%8B%9D-4%ED%9A%8C%EC%B0%A8\" aria-label=\"우아한 테크러닝 4회차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌟우아한 테크러닝 4회차</h2>\n<h3 id=\"promise\" style=\"position:relative;\"><a href=\"#promise\" aria-label=\"promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯promise</h3>\n<p>비동기\nconst x = 10;\nconst y = x * 10;\n동시실행 가능? -> 못함 왜? -> x가 할당되기 전이기 때문(dependency) == 변수적 의존성</p>\n<p>const x = () => 10;\nconst y = x() * 10;\nx값 확정순간은 y가 호출할때이므로 실행 가능 -> 지연호출</p>\n<p>Promise는 지연과 비슷\n두개의 함수를 전달하기위해 함수호출\nconst p = new Promise(funcion(resolve,reject){\n//p안에서 어떤일이 일어나도\nresolve(“1”);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//closuer 처럼 다른함수에 resolve삽입해두면\nsetTimeout(()=&gt;{\n    resolve(&quot;1&quot;)\n},1000) \n//함수안에서 지연되어 호출됨</code></pre></div>\n<p>})\np.then(function(r){\nconsole.log(r)\n//얘가 1이 됨\n})</p>\n<h3 id=\"generator\" style=\"position:relative;\"><a href=\"#generator\" aria-label=\"generator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯generator</h3>\n<ul>\n<li>yeild -> 프로미스 외에도 다양한 타입에서 사용가능</li>\n</ul>\n<p>function* make(){\nreturn 1;\n}</p>\n<p>const i = make();\n//메이크 호출 -> i에는 보통 1ㅇ이 들어오지만, generator을 쓰면 객체가 됨.\n이 객체는 제너레이터 객체 </p>\n<p>함수는 인자를 받고 입력값을 받아 계산 한 뒤 값을 리턴\n리턴이 없으면 프로시져 -> 값을 넘겨서 계산할 수 잇으므로 상태 못가짐</p>\n<p>함수가 호출자한테 리턴을 여러번 할 수 있다면? == 함수가 호출될때\n처음부터 시작하지않고 마지막 리턴지점부터 다시 시작한다면? == 코루틴</p>\n<p>코루틴의 일부를 차용해서 제너레이터로 명명\n계속 어떤 값을 생성해내므로..ㅇㅇ </p>\n<p>let num = 1;\nfunction* makenumber(){\nwhile(true){\n//제너레이터 안의 리턴은 yeild == 함수를 끝내지않고 다시 돌아오겠다~\nyeild num++;\n}</p>\n<p>}</p>\n<p>const i = makeNumber();</p>\n<p>원래라면 무한루프니까 브라우저가 죽는데 제너레이터하면 안죽음\n어떻게?\n컴퓨터가 알아서 후루루룩 하는게 아니라 next메소드를 통해서 함수 실행\ni가 제너레이터 객체를 넘겨받음 -> 이 안에 next라는 메소드가 있는데 얘를 통해 함수 실행 -> i.next() 실행시 객체를 넘김 -> 더이상 호출 불가하다면 next대신 done 이 옴</p>\n<p>함수 바깥이랑 함수 내부랑 커뮤니케이션 하는 느낌으로 이해하면 좋을듯!</p>\n<p>let num = 1;\nfunction* makenumber(){\nwhile(true){\n//제너레이터 안의 리턴은 yeild == 함수를 끝내지않고 다시 돌아오겠다~\nyeild num++;\n}</p>\n<p>}</p>\n<p>const delay = ms => new Promise((resolve)=>seTimeout(resolve,ms));</p>\n<p>//dealy(10)은 프로미스 객체를 반환하므로 then으로 받음(콜백함수 구조)\ndelay(10).then()=>{\nconsole.log(‘3초뒤’)\n}</p>\n<p>//위의 방법 말고 이렇게 작성하면..?\n바깥쪽에선 함수 내부를 제어하고 함수안에서는 비동기를 동기처럼 푸는 느낌.</p>\n<p>function* main(){\nyeild delay(3000);\nconsole.log(‘3초뒤’);\n}</p>\n<p>//여기서 부터 지워보면 main이 동기처럼 보임.\n//넥스트가 담긴 객체가 리턴됨\nconst it = main();\n//넥스트하면 프로미스 객체가 리턴됨\n//프로미스 객체가 value 랑 done이 오는데 value만 취하겠다는 뜻 (구조분해할당)\nconst {value} = it.next()</p>\n<p>value.then(()=>{\n//3초뒤에 콘솔로그 문자 출력\nit.next();\n})</p>\n<h3 id=\"async\" style=\"position:relative;\"><a href=\"#async\" aria-label=\"async permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎯async</h3>\n<p>async function bar()\nasync await -> 프로미스객체 있을때만 사용</p>\n<p>async function* main(){\nawait delay(3000);\nconsole.log(‘3초뒤’);\n}</p>\n<p>main();</p>","frontmatter":{"title":"[우아한 테크러닝] 4회차 정리","date":"September 10, 2020"}}},"pageContext":{"slug":"/Frontend_log/2020-09-10-TIL2/","previous":{"fields":{"slug":"/Java/2020-09-09-TIL/"},"frontmatter":{"title":"[Java] 자바 내용정리3","category":"Java","draft":false}},"next":{"fields":{"slug":"/Java/2020-09-13-TIL/"},"frontmatter":{"title":"[Java] 자바 내용정리4(fin)","category":"Java","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}